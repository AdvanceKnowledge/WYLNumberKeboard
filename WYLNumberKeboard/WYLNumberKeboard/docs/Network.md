# 网络
## 1.网络七层协议
- 应用层：

	1.用户接口、应用程序；

	2.Application典型设备：网关；

	3.典型协议、标准和应用：TELNET、FTP、HTTP

- 表示层：
	
	1.数据表示、压缩和加密presentation

	2.典型设备：网关

	3.典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG

	4.表示层相当于一个东西的表示，表示的一些协议，比如图片、声音和视频MPEG。

- 会话层：

	1.会话的建立和结束；

	2.典型设备：网关；

	3.典型协议、标准和应用：RPC、SQL、NFS、X WINDOWS、ASP

- 传输层：

	1.主要功能：端到端控制Transport；

	2.典型设备：网关；

	3.典型协议、标准和应用：TCP、UDP、SPX

- 网络层：

	1.主要功能：路由、寻址Network；

	2.典型设备：路由器；

	3.典型协议、标准和应用：IP、IPX、APPLETALK、ICMP；

- 数据链路层：

	1.主要功能：保证无差错的疏忽链路的data link；

	2.典型设备：交换机、网桥、网卡；

	3.典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；

- 物理层：

	1.主要功能：传输比特流Physical；

	2.典型设备：集线器、中继器

	3.典型协议、标准和应用：V.35、EIA/TIA-232.

## 2.Http 和 Https 的区别？Https为什么更加安全？
- 区别
	
	1.HTTPS 需要向机构申请 CA 证书，极少免费。

	2.HTTP 属于明文传输，HTTPS基于 SSL 进行加密传输。

	3.HTTP 端口号为 80，HTTPS 端口号为 443 。

	4.HTTPS 是加密传输，有身份验证的环节，更加安全。
- 安全

	SSL(安全套接层) TLS(传输层安全)

	以上两者在传输层之上，对网络连接进行加密处理，保障数据的完整性，更加的安全。

## 3.HTTPS的连接建立流程

HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。在传输的过程中会涉及到三个密钥：

- 服务器端的公钥和私钥，用来进行非对称加密

- 客户端生成的随机密钥，用来进行对称加密
	
	![https](https://qn.nobady.cn/iOS/https.png)

如上图，HTTPS连接过程大致可分为八步:

- 1、客户端访问HTTPS连接。
	
	客户端会把安全协议版本号、客户端支持的加密算法列表、随机数C发给服务端。

- 2、服务端发送证书给客户端

	服务端接收密钥算法配件后，会和自己支持的加密算法列表进行比对，如果不符合，则断开连接。否则，服务端会在该算法列表中，选择一种对称算法（如AES）、一种公钥算法（如具有特定秘钥长度的RSA）和一种MAC算法发给客户端。
	
	服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
	
	在发送加密算法的同时还会把数字证书和随机数S发送给客户端

- 3、客户端验证server证书

	会对server公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。

- 4、客户端组装会话秘钥
	
	如果公钥合格，那么客户端会用服务器公钥来生成一个前主秘钥(Pre-Master Secret，PMS)，并通过该前主秘钥和随机数C、S来组装成会话秘钥

- 5、客户端将前主秘钥加密发送给服务端

	是通过服务端的公钥来对前主秘钥进行非对称加密，发送给服务端

- 6、服务端通过私钥解密得到前主秘钥

	服务端接收到加密信息后，用私钥解密得到主秘钥。

- 7、服务端组装会话秘钥

	服务端通过前主秘钥和随机数C、S来组装会话秘钥。

	至此，服务端和客户端都已经知道了用于此次会话的主秘钥。

- 8、数据传输

	客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。
	
	同理，服务端收到客户端发送来的密文，用服务端密钥对其进行对称解密，得到客户端发送的数据。

## 4.解释一下 三次握手 和 四次挥手

- 三次握手
	
	1.由客户端向服务端发送 SYN 同步报文。

	2.当服务端收到 SYN 同步报文之后，会返回给客户端 SYN 同步报文和 ACK 确认报文。

	3.客户端会向服务端发送 ACK 确认报文，此时客户端和服务端的连接正式建立。

- 建立连接
	
	1.这个时候客户端就可以通过 Http 请求报文，向服务端发送请求

	2.服务端接收到客户端的请求之后，向客户端回复 Http 响应报文。

- 四次挥手

	当客户端和服务端的连接想要断开的时候，要经历四次挥手的过程，步骤如下：

	1.先由客户端向服务端发送 FIN 结束报文。

	2.服务端会返回给客户端 ACK 确认报文 。此时，由客户端发起的断开连接已经完成。

	3.服务端会发送给客户端 FIN 结束报文 和 ACK 确认报文。

	4.客户端会返回 ACK 确认报文到服务端，至此，由服务端方向的断开连接已经完成。

## 5.TCP 和 UDP的区别

- TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。

- UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。

## 6.Cookie和Session

cookie
	
- 1.用户与服务器的交互

	cookie主要是用来记录用户状态，区分用户，状态保存在客户端。cookie功能需要浏览器的支持。如果浏览器不支持cookie（如大部分手机中的浏览器）或者把cookie禁用了，cookie功能就会失效。
	![cookie](https://qn.nobady.cn/iOS/cookie.png)

	a).首次访问amazon时，客户端发送一个HTTP请求到服务器端 。服务器端发送一个HTTP响应到客户端，其中包含Set-Cookie头部

	b).客户端发送一个HTTP请求到服务器端，其中包含Cookie头部。服务器端发送一个HTTP响应到客户端

	c).隔段时间再去访问时，客户端会直接发包含Cookie头部的HTTP请求。服务器端发送一个HTTP响应到客户端

- 2.cookie的修改和删除
	
	在修改cookie的时候，只需要新cookie覆盖旧cookie即可，在覆盖的时候，由于Cookie具有不可跨域名性，注意name、path、domain需与原cookie一致
	
	删除cookie也一样，设置cookie的过期时间expires为过去的一个时间点，或者maxAge = 0(Cookie的有效期,单位为秒)即可

- 3、cookie的安全

	事实上，cookie的使用存在争议，因为它被认为是对用户隐私的一种侵害，而且cookie并不安全
	
	HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。使用HTTP协议传输很机密的内容是一种隐患。

	
	a).如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。

	b).此外，secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密。

	c).也可以设置cookie为HttpOnly，如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS（跨站脚本攻击）攻击

Session

- Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。

- Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。
客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。

	![session](https://qn.nobady.cn/iOS/session.png)

- 如图：

	当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为SessionId）

	如果已包含则说明以前已经为此客户端创建过session，服务器就按照SessionId把这个session检索出来，使用（检索不到，会新建一个）

	如果客户端请求不包含SessionId，则为此客户端创建一个session并且生成一个与此session相关联的SessionId，SessionId的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个SessionId将被在本次响应中返回给客户端保存。

	保存这个SessionId的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把SessionId传递回服务器。

Cookie 和Session 的区别：

- 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

- 2、cookie相比session不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。

- 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。

- 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。而session存储在服务端，可以无限量存储

- 5、所以：将登录信息等重要信息存放为session;其他信息如果需要保留，可以放在cookie中

## 7.DNS是什么

因特网上的主机，可以使用多种方式标识，比如主机名或IP地址。一种标识方法就是用它的主机名（hostname），比如·www.baidu.com、www.google.com、gaia.cs.umass.edu等。这方式方便人们记忆和接受，但是这种长度不一、没有规律的字符串路由器并不方便处理。还有一种方式，就是直接使用定长的、有着清晰层次结构的IP地址，路由器比较热衷于这种方式。为了折衷这两种方式，我们需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统（Domain Name System，DNS）的主要任务。

- DNS是：
	
	1、一个由分层的DNS服务器实现的分布式数据库

	2、一个使得主机能够查询分布式数据库的应用层协议


- DNS服务器通常是运行BIND软件的UNIX机器，DNS协议运行在UDP上，使用53号端口

- DNS通常是由其他应用层协议所使用的，包括HTTP、SMTP等。其作用则是：将用户提供的主机名解析为IP地址

- DNS的一种简单设计就是在因特网上只使用一个DNS服务器，该服务器包含所有的映射。很明显这种设计是有很大的问题的：

	单点故障：如果该DNS服务器崩溃，全世界的网络随之瘫痪

	通信容量：单个DNS服务器必须处理所有DNS查询

	远距离的集中式数据库：单个DNS服务器必须面对所有用户，距离过远会有严重的时延。

	维护：该数据库过于庞大，还需要对新添加的主机频繁更新。

所以，DNS被设计成了一个分布式、层次数据库

## 8.DNS解析过程

以www.163.com为例:

- 客户端打开浏览器，输入一个域名。比如输入www.163.com，这时，客户端会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。

- 查询www.163.com的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。

- 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。

- 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。

- 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。






	